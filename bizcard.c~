/*
 * GccApplication2.c
 *
 * Created: 8/11/2017 2:28:24 PM
 * Author : EpicZero
 */ 

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

#define CAPSENSE 0x10 //PB4

volatile uint16_t ledbitarray = 0x0; //initial LED states

const  uint8_t LED_RDY[12] = { 0x9,
                               0xA,
                               0xC,
                               0xC,
                               0x5,
                               0x6,
                               0x6,
                               0xA,
                               0x3,
                               0x3,
                               0x5,
                               0x9};

const uint8_t LED[12] = {  0x1,
                           0x2,
                           0x4,
                           0x8,
                           0x1,
                           0x2,
                           0x4,
                           0x8,
                           0x1,
                           0x2,
                           0x4,
                           0x8};

static void initTimer(void)
{
TCCR1 = 0; //reset
TCNT1 = 0; //reset
GTCCR = (1<<PSR1);
OCR1A = 5; //compareA triggers interrupt 125
OCR1C = 20; //compareC resets updown counter 243
TIMSK = (1 << OCIE1A);//enable compare match interrupt
TCCR1 = (1<<CTC1) | (1<<CS12) | (1<<CS11) | (1<<CS10);  
sei();
}

//LED cycle
volatile uint32_t cnt = 0;
ISR(TIMER1_COMPA_vect) {

    //always clear matrix
    PORTB &= ~0xF; //(todo: mask capsense pin)
    DDRB &= ~0xF; //(todo: mask capsense pin)

    uint8_t index = cnt%12;

    //if led is supposed to be on
    if ((ledbitarray >> index) & 0x1) 
    { 
    //configure matrix (todo: mask capsense pin)
    DDRB |= LED_RDY[index];

    //turn LED on (todo: mask capsense pin)
    PORTB |= LED[index];
    }

    //always incriment counter
    cnt++;
  }


volatile int analogresult = 0;
ISR(ADC_vect)
{
    analogresult = (ADCH<<8)|ADCL;
}

uint8_t direction = 1;
int main(void)
{
    DDRB &= ~(1<<DDB4); //configure pb3 as adc input
    ADMUX &= ~( (1<<REFS1) | (1<<REFS0) | (1<<ADLAR) );//ref voltage and right adjust
    ADMUX |= (1<<MUX1);//sel adc2
    ADCSRB &= ~( (1<<ADTS2) | (1 << ADTS1) | (1 << ADTS0) );
    //DIDR0 |= (1<<ADC20);
    ADCSRA |= (1<<ADEN) | (1<< ADIE) | (1<< ADATE);



    initTimer();

    //start adc conversions (free running mode)
    ADCSRA |= (1<<ADSC);

    while (1) 
    {       
           
            _delay_ms(25);/*
            if(direction)
            { 
                ledbitarray <<= 0x1; //shift left one position
                ledbitarray |= 0x1; //add one led
            }
            else
            {
                ledbitarray >>= 0x1;
            }
            
	    if(ledbitarray == 0xFFF)
            {
                direction = 0; 
            }
            if(ledbitarray == 0)
            {
                direction = 1;
            }*/


	    ledbitarray = (0x1<<(analogresult/100));

    }
}
